# qWGAN

The code in this directory can be used to create a quantum Wasserstein Generative Adversarial Network (qWGAN) using the quantum simulator package **Pennylane**. For a detailed overview of the qWGAN, please see  our paper "Quantum Earth Mover's Distance: A New Approach to Learning Quantum Data".

## Requirements
Most importantly, please install the package `Pennylane` (https://pennylane.ai/) which is the package we use to simulate quantum circuits. The following packages are also needed to run the code: `numpy`, `pandas`, `tensorflow`.

## Configuration 
Please see the `config.py` file to setup the code to use different **Pennylane** interfaces. Here, you will find various options available for configuring the **Pennylane** package. Importantly, please note that certain settings are required to run some of the files as discussed below.

## Constructing a qWGAN
To construct a qWGAN, one must first setup a discriminator and generator. All code needed to setup a qWGAN and the discriminator and generator is in the `QWGAN.py` file.

First, as shown below, load relevant classes from `QWGAN.py`. Two important parameters to first choose are the number of qubits `n` and the order of the discriminator `k` (i.e. the order of the Pauli observables which the discriminator is initialized with).

As an example below, we show how one can setup the qWGAN to learn the pure GHZ state. Here, we use the tensorflow backend.

```
from QGAN import generator, discriminator, QGAN
import numpy as np
import math
import tensorflow as tf

n=3 # three qubits
k=2 # discriminator initialized with up to order two paulis
```

The discriminator is initialized with the parameters `n`, `k`, and a target state (here, the target state is pure, but it can also be initialized to a mixed state). 

```
# target state in numpy format that is later given to discriminator
state = np.asarray(np.zeros(2**n).astype(np.complex128)) 
state[0] = np.sqrt(2)/2
state[-1] = np.sqrt(2)/2
dis = discriminator(state,n,k)
```

The generator is initialized with a **Pennylane** circuit (or circuits) and initial circuit parameters. First, we design a simple circuit function to generate the 3 qubit GHZ state.
```
import pennylane as qml
def circuit_fun(params, **kwargs):
	qml.RX(params[0], wires = 0)
	qml.RY(params[1], wires = 0)
	qml.RZ(params[2], wires = 0)
	for i in range(2):
        qml.CRX(params[3+i*3+0], wires = [i,i+1])
		qml.CRY(params[3+i*3+1], wires = [i,i+1])
		qml.CRZ(params[3+i*3+2], wires = [i,i+1])
```
Then, we input the circuit above into our generator. Note, that since the generator optimizes over a set of circuits, even if we use only one circuit, we must insert that circuit (and its initial parameters) into a list.
```
circuits = [circuit_fun]
initial_params = tf.Variable(tf.convert_to_tensor(np.random.normal(size = 9)))
params  = [initial_params]
gen = generator(circuits,params,n)
```

Finally, we can combine the generator and discriminator into a qWGAN with the class `QGAN` and optimize it!
```
qgan = QGAN(gen,dis)
qgan.optimize(optimizer = 'Adam', steps = 1000)
```

## Simulations performed
All simulations performed using the qWGAN for our paper begin with the file prefix `run_`. All outputs are saved to the `csv_files/` directory. See our paper for full details on all the circuits and experiments. The experiments are listed below:
- `run_bp_teacher_student.py`: experiment where student circuit aims to learn circuit of same form but with random parameters (teacher circuit). 
- `run_butterfly_random.py`: learning of mixed states generated by butterfly cirucits. Due to issues in the **Pennylane** package with handling higher order Pauli measurements, errors may be observed when using the `diff_method=backprop` in the configuration.
- `run_GHZ_target.py`: learning of a target state which is the GHZ state using a simple GHZ generating circuit. Due to issues in the **Pennylane** package with handling higher order Pauli measurements, errors may be observed when using the `diff_method=backprop` in the configuration.
- `run_gradients_bp.py`: comparison of gradients when using a qWGAN to a conventional quantum GAN. Configuration must be set to the `default.qubit.tf` interface with a `diff_method=backprop` for this to work.
- `run_qaoa_target.py`: learning of the ground state of a simple QAOA hamiltonian. Due to issues in the **Pennylane** package with handling higher order Pauli measurements, errors may be observed when using the `diff_method=backprop` in the configuration.

## Authors

* [Bobak Kiani](https://github.com/bkiani) (MIT) 
* Giacomo De Palma (Scuola Normale Superiore)
* Milad Marvian(University of New Mexico)
* Zi-Wen Liu(Perimeter Institute)
* Seth Lloyd (MIT)
